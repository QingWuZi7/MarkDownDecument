[TOC]

> 现在几乎大多数的语言或工具都支持正则表达式,用来完成搜索和替换操作.

## 匹配单字符
|      目的       |  模式  |                    含义                     |                        进阶                         |
| :-------------: | :----: | :-----------------------------------------: | :-------------------------------------------------: |
|  匹配普通文本   |   a    |     匹配(a)字符,当然还可以是(pxn)字符串     |              如果相匹配任意字符怎么办?              |
|                 | ac\|bc | OR(或)操作符 \|<br>匹配\|字符左右两边的内容 |            19\|20x和(19)\|(20)x有何区别?            |
|  匹配任意字符   |   .    |          匹配单字符(换行符除外身)           |          组合起来@,如果只想匹配(.)字符呢?           |
| <b>转义字符</b> |  \\.   |     需要匹配自身这种特殊字符时,需要转义     | <b>反斜杠</b>( \\ )<br>字符 \\ 后面总是跟着一个字符 |
> 正则表达式,也被称为模式,是由字符构成的字符串.  
> 字符分为字面字符和元字符,又特殊含义的字符序列总是以\字符开头.

## 空白字符
|元字符|模式|含义|
|:-:|:-:|:-:|
|[\b]|回退(删除)||
|\f|换页符||
|\n|换行符||
|\r|回车符||
|\t|制表符||
|\v|垂直制表符||

## 匹配一组字符
|         目的          |  模式   |                             含义                             |                             进阶                             |
| :-------------------: | :-----: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|       字符集合        |  [Bb]   | 匹配B或b,<b>中括号</b>只负责定义一个集合.<br>配对的元字符如[ ]不做元字符时需要被转义 | 匹配集合中某个成员@大小写<br>适合用在局部不区分字母大小写的搜索里 |
|       字符集合        | [01234] |                     匹配一个在0到4的数字                     |                       区间很大怎么办?                        |
|        连字符         |  [0-4]  |                匹配在0到4之间,原理是ASCII码序                |               [A-Za-z0-9]连字符只在此场合使用                |
| 集合取反(<b>排除</b>) | [^0-4]  |                  匹配0到4之外,原理ASCII码序                  |               适合用在只要小小部分字符排除在外               |
> 一些常用的字符集合可以用特殊元字符代替(类元字符).  
> 正则表达式的写法几乎总是不止一种,挑选你自己觉得最舒服的那种即可.

| 目的 |        模式         |     含义      | 进阶 |
| :--: | :-----------------: | :-----------: | :--: |
|  \d  |  任何一个数字字符   |     [0-9]     |      |
|  \D  |   任何一个非数字    |    [^0-9]     |      |
|  \w  | 字母数字字符,和(\_) | [a-zA-Z0-9_]  |      |
|  \W  |      对上取反       | [^a-zA-Z0-9_] |      |
|  \s  |  任何一个空白字符   | [\f\n\r\t\v]  |      |
|  \S  | 任何一个非空白字符  | [^\f\n\r\t\v] |      |

## 重复匹配、指定次数
> 重复范围在 { } 中指定

|  元字符   | 目的                                                     | 懒惰型版本 |      举例       |       进阶       |
| :-------: | :------------------------------------------------------- | :--------: | :-------------: | :--------------: |
|    {n}    | 匹配前一个字符(集合)n次                                  |            | #[A-Fa-f0-9]{6} |                  |
|   {n,}    | 匹配前一个字符(集合)至少n次                              | =={n,}?==  |                 |                  |
| {min,max} | 匹配前一个字符(集合)min次到max次                         |            |                 |                  |
|     +     | 匹配一次或多次,等同于 {1,}                               |   ==+?==   |     [\w.]+      | 如果开头就是点呢 |
|    \*     | 匹配零次或多次,等同于 {0,}<br>可理解为“使其可选”的元字符 |  ==\*?==   |    \w[\w.]*     |                  |
|     ?     | 匹配零个或一个,等同于 {0,1}                              |            |     https?      |                  |

> \*和\+是“贪婪型”(greedy)元字符。会尽可能从开头一直匹配到末尾，而不是完成第一个给匹配就停止。
> 懒惰型lazy版本匹配**尽可能少**的字符。
> 例如\<b>xxx\</b>QQQ\<b>yyy\</b>使用正则表达式/<[Bb]>.\*<\\ /[Bb]>/时会得到所有文本。<u>因为\*是贪婪的</u>,所以.*会尽可能的长。
> 而使用/<[Bb]>.\*?<\\ /Bb>/会得到两段，而非一段。

## 边界
|     元字符     |                 目的                  |          举例           |       含义       |      进阶       |
| :------------: | :-----------------------------------: | :---------------------: | :--------------: | :-------------: |
| \b<br>boundary | 一个单词的开头或结尾<br>一边\w,一边\W |  this ==cat== scatterd  | \bcat<br>\bcat\b | 得到c是单词边界 |
|       \B       |     非单词边界<br>两边都是\w或\W      | cat hcat cate h==cat==e |     \Bcat\B      |                 |
|       ^        |              字符串起始               |                         |                  |                 |
|       $        |              字符串末尾               |                         |                  |                 |


## 子表达式
> 元字符[^1] ( )

1.使用子表达式来分组  

> 查找:Pinging www.d.s.ocm [<u>12.159.46.200</u>]中的<b>IP地址</b>

- <b>暴力模式:</b> \d{1,3}\\.\d{1,3}\\.\d{1,3}\\.\d{1,3}\\.
- <b>子表达式模式:</b> (\d{1,3}\\.){3}<b>(</b>\d{1,3}<b>)</b> 最后的括号可有可<b>无</b>
- <b>子表达式嵌套,以实现IP地址的取值范围检查:</b>
- ( (<b>(</b>25[0-5]<b>)</b>|<b>(</b>2[0-4]\d<b>)</b>|<b>(</b>1\d{2}<b>)</b>|<b>(</b>\d{1,2}<b>)</b>)<> \\.){3}((<b>(</b>==25[0-5]==<b>)</b>|<b>(</b>==2[0-4]\d==<b>)</b>|<b>(</b>==1\d{2}==<b>)</b>|<b>(</b>==\d{1,2}==<b>)</b>))
    - 原理:  
    - 任意的1位或2位数字.
    - 任意的以1开头的3位数字.
    - 任意的以2开头,第二位数字在0到4之间的3位数字.
    - 任意的以25开头,第三位数字在0到5之间的3位数字.
> 将以上规则反向写成子表达式,因为<b>模式是从左到右进行评估的</b>(OR有短路机制),只要有任何模式匹配,就不子啊测试选择结构中的其他模式.

> 子表达式作用是把表达式的各个部分划分在一起,子表达式的常见的用途包括:通过重复次数元字符准确控制重复内容,正确地定义\|的多项分支.如有必要,子表达式还允许嵌套使用.


## 反向引用和方向查看
> 术语“反向引用”指的是这些实体引用的是先前的子表达式。  
> 可以把反向引用想象成变量，取名用<?Tag>放在子表达式中。  
> JS使用\来标识反向引用，替换操作用的是$

```js
let a='313-555-1234';
a.replace(/(\d{3}(-)(\d{3})(-)(\d{4})/,`($1) $3-$5`);
```
> 把文本分解成多个子表达式的做法可以更精细地控制文本。  

### 各种环视操作
> 想记住位置,但是不要将这个位置上的东西成为结果的一部分.例如<Title>aa</Title>里面通过'title'来定位,但是结果只有'aaa',不需要有'title'

http:--wweasdw.efor.com  
http:--dsaf.com  
ftp:--as.com  

使用/.+(?=:)/模式,匹配到(没有冒号)  
==http==:--wweasdw.efor.com  
==http==:--dsaf.com  
==ftp==:--as.com  

使用/.+(:)/则匹配到(含有冒号)  
==http:==--wweasdw.efor.com  
==http:==--dsaf.com  
==ftp:==--as.com  



|种类|说明|
|:-:|:-:|
|(?=)|肯定式向前查看|
|(?!)|否定式向前查看|
|(?<=)|肯定式向后查看|
|(?<!)|否定式向后查看|

> 向前查看模式的长度是可变的，其中可以包含.和+等量词  
> 向后产看只能是固定长度。  
> 环视不消耗匹配到的文本


```javaScript
var str1="let6of of -oop-";
console.log(str1.match(/(?<=le)(\w+)[ ]/g));
//let a=str1.match(/(?<=[ ])(?<Tag>\w+)[ ]/g).groups;
//const {Tag}=a;
//console.log(Tag);

//向后查看(再命名)+命名捕获.  
const group="a10-24-2021b11-21-2020".match(/(?<=(?<sd>b))(?<Month>\d{2})-(?<Day>\d{2})-(?<Year>\d{4})/).groups;
//(?<sd> ?<=(b))这样是错的 似乎有结合的优先级?
console.log("a10-24-2021b11-21-2020".match(/(?<=(?<sd>b))(?<Month>\d{2})-(?<Day>\d{2})-(?<Year>\d{4})/));//成功
console.log(JSON.stringify(group));

var str2="let of of -oop-";
console.log(str2.match(/(?<=(\S))(\w+)[ ]/)); //et  1 l  2 et
console.log(str2.match(/((\w)[ ](\w))\w+/)); //t 0f    1 t 0  2 t  3 0      //[ ]是空格,
//想得到"of of",下面第一个会导致中间的空格是忽略的,这是不可能的
//console.log(str2.match(/(?<=([ ]))(\w+)(?=([ ]))\2/)); 
console.log(str2.match(/(?<=([ ]))(\w+)[ ]\2/));
```

```js
//向后查看的例子
let str="I paid $30 for 100 apples."
console.log(str.match(/(?<=\$)\d+/)); //30 ->价格
console.log(str.match(/(?<!\$)\d+/)); //0 ->30中的那个'0' 错误
console.log(str.match(/\b(?<!\$)\d+\b/));//100 ->数量（加上单词边界）
```


## 大小写转换
|元字符|说明|位置|
|:-:|:-:|:-:|
|\E|结束\L或\U转换|
|\l|把下一个字符传唤成小写|字符或子表达式之前|
|\L|把\L和\E之间的字符全部转换为小写|和\E组成的区间|
|\u|把下一个字符转换成大写|字符或子表达式之前|
|\U|把\U和\E之间的字符全部转换为大写|和\E组成的区间|

```js
let a1029='asdg<h1>Hello</h1>'
console.log(a1029.replace(/([Hh]1)(\w)([\\Hh1])/,'$1\U$2\E$3'));
```

[^1]:元字符是一些在正则表达式里有着特殊含义的字符。加反斜杠才能代表字符自身。
